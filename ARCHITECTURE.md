# NullEye — Architecture (detailed)

This document describes NullEye's internal architecture, key dataflows, and important design decisions.

## High-level components

- Core
  - Event bus: lock-free ring buffer (multi-producer, multi-consumer) for inter-module event exchange.
  - Configuration: YAML-driven with defaults and a minimal fallback parser if `libyaml` is absent.
  - Persistence: SQLite (WAL) for event logs, file inventory, alerts, and serialized AI models.
  - Logger: buffered file output + syslog; recent messages kept in-memory for UI panels.

- Telemetry
  - eBPF (optional): CO-RE BPF programs (execve, open, connect, sendto, recvfrom, vfs_read/write, etc.) emit compact events into a BPF ring buffer.
  - Userspace loader: enumerates `src/ebpf/bpf/*.bpf.o`, loads objects, attaches programs and forwards events into the core event bus.

- Modules
  - FileIntegrity: scheduled scanner, SHA-256 + Merkle root per file, DB upsert and event emission.
  - ProcessMonitor / NetworkMonitor / UserMonitor: consume events from the bus and persist relevant entries.
  - AIEngine: online scoring (isolation forest) and lightweight LSTM predictor for sequence anomalies.

- UI & Integrations
  - TUI: ncurses-driven dashboard (stdout fallback available).
  - Plugins: C plugin API and Python runner for custom logic.
  - Metrics: minimal Prometheus `/metrics` endpoint.

## Event model

Events are fixed-size C structs (`nuleye_event_t`) with fields:
- timestamp, module id, type, pid/ppid/uid/gid, comm, path, payload (up to 256 bytes)

Design goals: low allocation pressure, deterministic size for efficient bus copies.

## Dataflow (detailed)

1. Kernel/eBPF emits compact binary events into the BPF map `events`.
2. Userspace `ebpf_loader` polls the ring buffer and calls `event_bus_publish()`.
3. Consumers call `event_bus_consume()` in their worker loops, process events, and optionally persist to SQLite.
4. Alerts are generated by AI or rule matches and stored in `alerts` table; response engine may execute actions.

## Database schema (selected)

- `events(id INTEGER PRIMARY KEY, ts INTEGER, module TEXT, data BLOB)`
- `file_entries(path TEXT PRIMARY KEY, hash TEXT, merkle TEXT, mtime INTEGER, size INTEGER, perms INTEGER, uid INTEGER, gid INTEGER, attrs TEXT)`
- `alerts(id INTEGER PRIMARY KEY, ts INTEGER, severity TEXT, module TEXT, message TEXT, acknowledged INTEGER DEFAULT 0)`
- `model(key TEXT PRIMARY KEY, blob BLOB)`

## Plugin API (summary)

Plugins provide a `nulleye_module_get()` symbol returning a `nuleye_module_t` structure with callbacks:
- `init()` / `fini()` — lifecycle hooks
- `process_event()` — optional event callback
- `tui_draw()` — optional UI rendering callback

Load path: `/usr/lib/nulleye/plugins`

## Error handling & resiliency

- Optional features (libbpf, libyaml, ncurses) are non-fatal; NullEye logs and continues with fallbacks.
- Event-bus uses overwrite/backpressure semantics to avoid blocking producers.
- Each module runs in its own worker thread; thread start failures are logged and the module disabled.

## Security considerations

- eBPF attach requires root; userspace drops privileges after attach where possible.
- SQLite files and logs should be stored on secure volumes with proper ACLs.
- Response actions (e.g., kill process, block IP) are guarded and logged to avoid accidental misuse.

## Extending NullEye

- Add a module: implement `nuleye_module_t` callbacks and `module_register_builtin()` or package as a plugin.
- Add eBPF telemetry: add a CO-RE-safe `.bpf.c` file under `src/ebpf/bpf/`, build with clang/bpftool.

## Performance notes

- Event bus sizing (configurable) determines in-memory buffering capacity; choose based on host workload.
- eBPF programs are intentionally compact to minimize kernel/user-space overhead.

## Operational checklist

- Backup DB before upgrades.
- Verify BPF load on systems with BTF and required toolchain.
- Use `nulleye --diag` and `/metrics` for quick health checks.
